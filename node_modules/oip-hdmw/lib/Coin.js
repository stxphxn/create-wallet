'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bip = require('bip32');

var _bip2 = _interopRequireDefault(_bip);

var _bip32Utils = require('bip32-utils');

var _bip32Utils2 = _interopRequireDefault(_bip32Utils);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _Account = require('./Account');

var _Account2 = _interopRequireDefault(_Account);

var _TransactionBuilder = require('./TransactionBuilder');

var _TransactionBuilder2 = _interopRequireDefault(_TransactionBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var COIN_START = 0x80000000;

/**
 * Manage Accounts for a specific Coin
 */

var Coin = function () {
	/**
  * Create a new Coin object to interact with Accounts and Chains for that coin. This spawns a BIP44 compatable wallet.
  *
  * ##### Examples
  * Create a new Coin using a specified seed.
  *```
  *import { Coin, Networks } from 'oip-hdmw'
  *
  * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
  *```
  * Create a new Coin using a specified seed, don't auto discover.
  *```
  *import { Coin, Networks } from 'oip-hdmw'
  *
  * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin, false)
  *```
  * @param  {string} node - BIP32 Node already derived to m/44'
  * @param  {CoinInfo} coin - The CoinInfo containing network & version variables
  * @param  {Object} [options] - The Options for spawning the Coin
  * @param  {boolean} [options.discover=true] - Should the Coin auto-discover Accounts and Chains
  * @param  {Object} [options.serialized_data] - The Data to de-serialize from
  * @return {Coin}
  */
	function Coin(node, coin, options) {
		_classCallCheck(this, Coin);

		if (typeof node === "string") this.seed = node;else this.seed = node.toBase58();

		this.coin = coin;

		this.discover = true;

		if (options && options.discover !== undefined) this.discover = options.discover;

		var purposeNode = _bip2.default.fromBase58(this.seed);
		purposeNode.network = this.coin.network;

		var bip44Num = this.coin.network.slip44;

		// Check if we need to convert the hexa to the index
		if (bip44Num >= COIN_START) bip44Num -= COIN_START;

		this.root = purposeNode.derivePath(bip44Num + "'");

		this.accounts = {};

		// Setup EventEmitter to notify when we have changed
		this.event_emitter = new _eventemitter2.default();

		if (options && options.serialized_data) this.deserialize(options.serialized_data);

		if (this.discover) {
			this.discoverAccounts();
		}
	}

	_createClass(Coin, [{
		key: 'serialize',
		value: function serialize() {
			var serialized_accounts = {};

			for (var account_number in this.accounts) {
				serialized_accounts[account_number] = this.accounts[account_number].serialize();
			}

			return {
				name: this.coin.name,
				network: this.coin.network,
				seed: this.seed,
				accounts: serialized_accounts
			};
		}
	}, {
		key: 'deserialize',
		value: function deserialize(serialized_data) {
			if (serialized_data) {
				if (serialized_data.accounts) {
					for (var account_number in serialized_data.accounts) {
						var account_master = _bip2.default.fromBase58(serialized_data.accounts[account_number].extended_private_key, this.coin.network);

						this.accounts[account_number] = new _Account2.default(account_master, this.coin, {
							discover: false,
							serialized_data: serialized_data.accounts[account_number]
						});
					}
				}
			}
		}
		/**
   * Get the balance for the entire coin, or a specific address/array of addresses
   * @param  {Object} [options] - Specific options defining what balance to get back
   * @param {Boolean} [options.discover=true] - Should the Coin discover Accounts
   * @param {number|Array.<number>} [options.accounts=All Accounts in Coin] - Get Balance for defined Accounts
   * @param {string|Array.<string>} [options.addresses=All Addresses in each Account in Coin] - Get Balance for defined Addresses
   * @example <caption> Get Balance for entire Coin</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * bitcoin.getBalance().then((balance) => {
   *  	console.log(balance)
   * })
   * @return {Promise<number>} A Promise that will resolve to the balance of the entire Coin
   */

	}, {
		key: 'getBalance',
		value: async function getBalance(options) {
			if (!options || options && options.discover === undefined || options && options.discover === true) {
				try {
					await this.discoverAccounts();
				} catch (e) {
					throw new Error("Unable to Discover Coin Accounts for getBalance! \n" + e);
				}
			}

			var accounts_to_search = [];

			// Check if we are an array (ex. [0,1,2]) or just a number (ex. 1)
			if (options && Array.isArray(options.accounts)) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = options.accounts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var accNum = _step.value;

						if (!isNaN(accNum)) {
							accounts_to_search.push(accNum);
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			} else if (options && !isNaN(options.accounts)) {
				accounts_to_search.push(options.accounts);
			} else {
				for (var accNum in this.accounts) {
					accounts_to_search.push(accNum);
				}
			}

			var totalBalance = 0;

			var addrsToSearch;

			if (options && options.addresses && (typeof options.addresses === "string" || Array.isArray(options.addresses))) {
				addrsToSearch = options.addresses;
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = accounts_to_search[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					accNum = _step2.value;

					if (this.accounts[accNum]) {
						try {
							var balance_res = await this.accounts[accNum].getBalance({
								discover: false,
								addresses: addrsToSearch,
								id: accNum
							});

							totalBalance += balance_res.balance;
						} catch (e) {
							throw new Error("Unable to get Coin balance! \n" + e);
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return totalBalance;
		}
		/**
   * Get a specific Address
   * @param  {number} [account_number=0] - Number of the account you wish to get the Address from
   * @param  {number} [chain_number=0] - Number of the Chain you wish to get the Address from
   * @param  {number} [address_index=0] - Index of the Address you wish to get
   * @return {Address}
   */

	}, {
		key: 'getAddress',
		value: function getAddress(account_number, chain_number, address_index) {
			return this.getAccount(account_number || 0).getAddress(chain_number, address_index);
		}
		/**
   * Get the Main Address for a specific Account number. 
   * This is the Address at index 0 on the External Chain of the Account.
   * @param  {number} [account_number=0] - Number of the Account you wish to get
   * @example <caption>Get Main Address for Coin</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var mainAddress = bitcoin.getMainAddress()
   * @example <caption>Get Main Address for Account #1 on Coin</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var mainAddress = bitcoin.getMainAddress(1)
   * @return {Address}
   */

	}, {
		key: 'getMainAddress',
		value: function getMainAddress(account_number) {
			return this.getAccount(account_number || 0).getMainAddress();
		}
		/**
   * Send a Payment to specified Addresses and Amounts
   * @param  {Object} options - the options for the specific transaction being sent
   * @param {OutputAddress|Array.<OutputAddress>} options.to - Define outputs for the Payment
   * @param {string|Array.<string>} [options.from=All Addresses in Coin] - Define what public address(es) you wish to send from
   * @param {number|Array.<number>} [options.fromAccounts=All Accounts in Coin] - Define what Accounts you wish to send from
   * @param {Boolean} [options.discover=true] - Should discovery happen before sending payment
   * @param {string} [options.floData=""] - Flo data to attach to the transaction
   * @return {Promise<string>} - Returns a promise that will resolve to the success TXID
   */

	}, {
		key: 'sendPayment',
		value: function sendPayment(options) {
			var _this = this;

			return new Promise(function (resolve, reject) {
				if (!options) reject(new Error("You must define your payment options!"));

				var processPayment = function processPayment() {
					var sendFrom = [];

					var allAddresses = [];

					// Add all Addresses from selected accounts to array
					for (var account in _this.accounts) {
						// Check if we are defining what accounts to send the payment from
						if (options.fromAccounts) {
							// Check if it is a single account number, or an array of account numbers
							if (typeof options.fromAccounts === "number") {
								// If we match the passed account number, set the grabbed addresses
								if (options.fromAccounts === parseInt(account)) {
									allAddresses = _this.accounts[account].getAddresses();
								}
							} else if (Array.isArray(options.fromAccounts)) {
								// If we are an array, itterate through
								var _iteratorNormalCompletion3 = true;
								var _didIteratorError3 = false;
								var _iteratorError3 = undefined;

								try {
									for (var _iterator3 = options.fromAccounts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
										var acs = _step3.value;

										if (acs === parseInt(account)) {
											allAddresses = allAddresses.concat(_this.accounts[account].getAddresses());
										}
									}
								} catch (err) {
									_didIteratorError3 = true;
									_iteratorError3 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion3 && _iterator3.return) {
											_iterator3.return();
										}
									} finally {
										if (_didIteratorError3) {
											throw _iteratorError3;
										}
									}
								}
							}
						} else {
							allAddresses = allAddresses.concat(_this.accounts[account].getAddresses());
						}
					}

					// Check if we define what address we wish to send from
					if (options.from) {
						// Check if it is a single from address or an array
						if (typeof options.from === "string") {
							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;

							try {
								for (var _iterator4 = allAddresses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var address = _step4.value;

									if (address.getPublicAddress() === options.from) {
										sendFrom.push(address);
									}
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4.return) {
										_iterator4.return();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						} else if (Array.isArray(options.from)) {
							var _iteratorNormalCompletion5 = true;
							var _didIteratorError5 = false;
							var _iteratorError5 = undefined;

							try {
								for (var _iterator5 = options.from[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
									var adr = _step5.value;
									var _iteratorNormalCompletion6 = true;
									var _didIteratorError6 = false;
									var _iteratorError6 = undefined;

									try {
										for (var _iterator6 = allAddresses[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
											var address = _step6.value;

											if (address.getPublicAddress() === adr) {
												sendFrom.push(address);
											}
										}
									} catch (err) {
										_didIteratorError6 = true;
										_iteratorError6 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion6 && _iterator6.return) {
												_iterator6.return();
											}
										} finally {
											if (_didIteratorError6) {
												throw _iteratorError6;
											}
										}
									}
								}
							} catch (err) {
								_didIteratorError5 = true;
								_iteratorError5 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion5 && _iterator5.return) {
										_iterator5.return();
									}
								} finally {
									if (_didIteratorError5) {
										throw _iteratorError5;
									}
								}
							}
						}
						// else add all the addresses on the Account that have received any txs
					} else {
						sendFrom = allAddresses;
					}

					if (sendFrom.length === 0) {
						reject(new Error("No Addresses match defined options.from Addresses!"));
						return;
					}

					var newOpts = options;

					newOpts.from = sendFrom;

					var txb = new _TransactionBuilder2.default(_this.coin, newOpts);
					txb.sendTX().then(resolve).catch(reject);
				};

				if (options.discover === false) {
					processPayment();
				} else {
					_this.discoverAccounts().then(processPayment).catch(reject);
				}
			});
		}
		/**
   * Get the Extended Private Key for the root path. This is derived at m/44'/coin_type'
   * @example <caption>Get the Extended Private Key for the entire Coin</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var extPrivateKey = bitcoin.getExtendedPrivateKey()
   * // extPrivateKey = xprv9x8MQtHNRrGgrnWPkUxjUC57DWKgkjobwAYUFedxVa2FAA5qaQuGqLkJnVcszqomTar51PCR8JiKnGGgzK9eJKGjbpUirKPVHxH2PU2Rc93
   * @return {string} The Extended Private Key
   */

	}, {
		key: 'getExtendedPrivateKey',
		value: function getExtendedPrivateKey() {
			return this.root.toBase58();
		}
		/**
   * Get the Neutered Extended Public Key for the root path. This is derived at m/44'/coin_type'
   * @example <caption>Get the Extended Private Key for the entire Coin</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var extPublicKey = bitcoin.getExtendedPrivateKey()
   * // extPublicKey = xpub6B7hpPpGGDpz5GarrWVjqL1qmYABACXTJPU5433a3uZE2xQz7xDXP94ndkjrxogjordTDSDaHY4i5G4HqRH6E9FJZk2F4ED4cbnprW2Vm9v
   * @return {string} The Extended Public Key
   */

	}, {
		key: 'getExtendedPublicKey',
		value: function getExtendedPublicKey() {
			return this.root.neutered().toBase58();
		}
		/**
   * Get the Account at the specified number
   * @param  {number} [account_number=0]
   * @example <caption>Get Default Account</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var account = bitcoin.getAccount()
   * @example <caption>Get Account #1</caption>
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var account = bitcoin.getAccount(1)
   * @return {Account}
   */

	}, {
		key: 'getAccount',
		value: function getAccount(account_number) {
			var num = account_number || 0;

			if (typeof account_number === "string" && !isNaN(parseInt(account_number))) num = parseInt(account_number);

			if (!this.accounts[num]) return this.addAccount(num);

			return this.accounts[num];
		}
		/**
   * Get all Accounts on the Coin
   * @example
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var accounts = bitcoin.getAccounts()
   * // accounts = {
   * // 	0: Account,
   * // 	1: Account
   * // }
   * @return {...Account} Returns a JSON object with accounts
   */

	}, {
		key: 'getAccounts',
		value: function getAccounts() {
			return this.accounts;
		}
		/**
   * Add the Account at the specified number, if it already exists, it returns the Account.
   * If the Account does not exist, it will create it and then return it.
   * @param  {number} [account_number=0]
   * @param {Boolean} [discover=discover Set in Coin Constructor] - Should the Account start auto-discovery.
   * @example
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var account = bitcoin.addAccount(1)
   * @return {Account}
   */

	}, {
		key: 'addAccount',
		value: function addAccount(account_number, discover) {
			var num = account_number || 0;

			if (typeof account_number === "string" && !isNaN(parseInt(account_number))) num = parseInt(account_number);

			// if the account has already been added, just return 
			if (this.accounts[num]) return this.getAccount(num);

			var accountMaster = this.root.deriveHardened(num);

			var shouldDiscover;

			if (discover !== undefined) shouldDiscover = discover;else shouldDiscover = this.discover;

			var account = new _Account2.default(accountMaster, this.coin, { discover: shouldDiscover });

			this.accounts[num] = account;

			return this.getAccount(num);
		}
		/**
   * Get the CoinInfo for the Coin
   * @example
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin)
   * var coin_info = bitcoin.getCoinInfo()
   * // coin_info = Networks.bitcoin
   * @return {CoinInfo}
   */

	}, {
		key: 'getCoinInfo',
		value: function getCoinInfo() {
			return this.coin;
		}
	}, {
		key: 'getHighestAccountNumber',
		value: function getHighestAccountNumber() {
			var highestAccountNumber = 0;

			for (var accNum in this.accounts) {
				if (accNum > highestAccountNumber) highestAccountNumber = accNum;
			}return parseInt(highestAccountNumber);
		}
		/**
   * Discover all Accounts for the Coin
   * @example
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin, false)
   * bitcoin.discoverAccounts().then((accounts) => {
   * 	console.log(accounts.length)
   * })
   * @return {Promise<Array.<Account>>} Returns a Promise that will resolve to an Array of Accounts once complete
   */

	}, {
		key: 'discoverAccounts',
		value: async function discoverAccounts() {

			// Reset the internal accounts
			this.accounts = {};

			// Get the Account #0 and start discovery there.
			try {
				await this.getAccount(0).discoverChains();
			} catch (e) {
				throw new Error("Unable to discoverAccounts! \n" + e);
			}

			while (this.accounts[this.getHighestAccountNumber()].getUsedAddresses().length > 0) {
				try {
					await this.getAccount(this.getHighestAccountNumber() + 1, false).discoverChains();
				} catch (e) {
					throw new Error("Unable to discover account #" + (this.getHighestAccountNumber() + 1) + "\n" + e);
				}
			}

			var discoveredAccounts = [];

			for (var accNum in this.accounts) {
				discoveredAccounts.push(this.accounts[accNum]);
			}

			this._subscribeToAccountWebsocketUpdates();

			return discoveredAccounts;
		}
		/**
   * Internal function used to subscribe to WebSocket updates for All Discovered Accounts
   */

	}, {
		key: '_subscribeToAccountWebsocketUpdates',
		value: function _subscribeToAccountWebsocketUpdates() {
			var accounts = this.getAccounts();

			for (var index in accounts) {
				accounts[index].onWebsocketUpdate(this._handleWebsocketUpdate.bind(this));
			}
		}
		/**
   * Internal function used to process Address updates streaming in from Websockets,
   * emits an update that can be subscribed to with onWebsocketUpdate
   * @param  {Object} update - Websocket Update Data
   */

	}, {
		key: '_handleWebsocketUpdate',
		value: function _handleWebsocketUpdate(address) {
			this.event_emitter.emit("websocket_update", address);
		}
		/**
   * Subscribe to events that are emitted when an Address update is recieved via Websocket
   * @param  {function} subscriber_function - The function you want called when there is an update
   *
   * @example
   * import { Coin, Networks } from 'oip-hdmw'
   *
   * var bitcoin = new Coin('00000000000000000000000000000000', Networks.bitcoin, false)
   * 
   * bitcoin.onWebsocketUpdate((address) => {
   * 		console.log(address.getPublicAddress() + " Recieved a Websocket Update!")
   * })
   */

	}, {
		key: 'onWebsocketUpdate',
		value: function onWebsocketUpdate(subscriber_function) {
			this.event_emitter.on("websocket_update", subscriber_function);
		}
	}]);

	return Coin;
}();

module.exports = Coin;