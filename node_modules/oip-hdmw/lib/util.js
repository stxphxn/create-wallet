'use strict';

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _safeBuffer = require('safe-buffer');

var _createHash = require('create-hash');

var _createHash2 = _interopRequireDefault(_createHash);

var _bs58check = require('bs58check');

var _bs58check2 = _interopRequireDefault(_bs58check);

var _wif = require('wif');

var _wif2 = _interopRequireDefault(_wif);

var _varuintBitcoin = require('varuint-bitcoin');

var _varuintBitcoin2 = _interopRequireDefault(_varuintBitcoin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @module util */

function ripemd160(buffer) {
	return (0, _createHash2.default)('rmd160').update(buffer).digest();
}

function sha256(buffer) {
	return (0, _createHash2.default)('sha256').update(buffer).digest();
}

function hash256(buffer) {
	return sha256(sha256(buffer));
}

function hash160(buffer) {
	return ripemd160(sha256(buffer));
}

function toBase58Check(hash, version) {
	var payload = _safeBuffer.Buffer.allocUnsafe(21);
	payload.writeUInt8(version, 0);
	hash.copy(payload, 1);

	return _bs58check2.default.encode(payload);
}

/**
 * @param  {Buffer} key - The buffer for the Private/Public Key to encode
 * @param  {number} version - The specific "version" byte to prepend
 * @return {string} Returns the Base58 encoded Key
 */
function toBase58(key, version) {
	if (!key) {
		return console.log("KEY NULL!!!!");
	}

	return toBase58Check(hash160(key), version);
}

/**
 * Check if a WIF is valid for a specific CoinNetwork
 * @param  {string} key - Base58 WIF Private Key
 * @param  {CoinNetwork} network
 * @return {Boolean}
 */
function isValidWIF(key, network) {
	try {
		var dec = _wif2.default.decode(key);

		if (network) {
			return dec.version === network.wif;
		} else {
			return true;
		}
	} catch (e) {
		console.error(e);
		return false;
	}
}

/**
 * Check if a Public Address is valid for a specific CoinNetwork
 * @param  {string} address - Base58 Public Address
 * @param  {CoinNetwork} network
 * @return {Boolean}
 */
function isValidPublicAddress(address, network) {
	try {
		var dec = _bitcoinjsLib2.default.address.fromBase58Check(address);
		if (network) {
			return dec.version === network.pubKeyHash || dec.version === network.scriptHash;
		} else {
			return true;
		}
	} catch (e) {
		return false;
	}
}

// https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery
async function discovery(chain, gapLimit, queryPromise, i, coin) {
	var gap = 0;
	var checked = 0;
	var allAddresses = [];

	var cycle = async function cycle(myCoin) {
		var batch = [chain.get()];
		checked++;

		while (batch.length < gapLimit) {
			chain.next();
			batch.push(chain.get());

			checked++;
		}

		try {
			var queryResultSet = await queryPromise(batch, myCoin);
		} catch (e) {
			throw new Error("discovery failed! \n" + e);
		}

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = queryResultSet.addresses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var adr = _step.value;

				allAddresses.push(adr);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		if (Array.isArray(queryResultSet.results)) throw new TypeError('Expected query set, not Array');

		// iterate batch, guarantees order agnostic of queryPromise result ordering
		batch.forEach(function (a) {
			if (queryResultSet.results[toBase58(a.address.publicKey, a.network.pubKeyHash)]) {
				gap = 0;
			} else {
				gap += 1;
			}
		});

		if (gap >= gapLimit) {
			var used = checked - gap;

			return { used: used, checked: checked, chainIndex: i, addresses: allAddresses };
		} else {
			chain.next();
		}

		try {
			return await cycle(myCoin);
		} catch (e) {
			throw new Error(e);
		}
	};

	try {
		return await cycle(coin);
	} catch (e) {
		throw new Error(e);
	}
}

/**
 * Check if a given string is in a BIP39 Mnemonic format (is a string, and is at least 2 words long). 
 * Please note that this does not validate if the Mnemonic is a valid BIP39 Mnemonic 
 * (i.e. defined from Entropy vs a Brain Wallet)
 * @param  {string} mnemonic - BIP39 Mnemonic to check
 * @return {Boolean}
 */
function isMnemonic(mnemonic) {
	if (typeof mnemonic === "string" && mnemonic.split(" ").length >= 2) return true;

	return false;
}

/**
 * Check if a given string is a BIP39 Entropy string.
 * @param  {string} entropy - The Entropy string to check
 * @return {Boolean}
 */
function isEntropy(entropy) {
	if (typeof entropy === "string" && entropy.length >= 16 && entropy.length <= 32) return true;

	return false;
}

module.exports = {
	hash160: hash160,
	hash256: hash256,
	toBase58: toBase58,
	isValidPublicAddress: isValidPublicAddress,
	isValidWIF: isValidWIF,
	isMnemonic: isMnemonic,
	isEntropy: isEntropy,
	discovery: discovery,
	varIntBuffer: _varuintBitcoin2.default.encode
};