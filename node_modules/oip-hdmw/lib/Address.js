'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _bitcoinjsMessage = require('bitcoinjs-message');

var _bitcoinjsMessage2 = _interopRequireDefault(_bitcoinjsMessage);

var _bip = require('bip32');

var _bip2 = _interopRequireDefault(_bip);

var _wif = require('wif');

var _wif2 = _interopRequireDefault(_wif);

var _bip32Utils = require('bip32-utils');

var _bip32Utils2 = _interopRequireDefault(_bip32Utils);

var _coinselect = require('coinselect');

var _coinselect2 = _interopRequireDefault(_coinselect);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ECPair = _bitcoinjsLib2.default.ECPair;

/**
 * [bitcoinjs-lib ECPair](https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/src/ecpair.js#L16)
 * @typedef {Object} ECPair
 */

/**
 * Contains information about an Unspent Transaction Output
 * @typedef {Object} utxo
 * @property {string} address - Base58 Public Address
 * @property {string} txid - The Transaction ID
 * @property {number} vout - The Index of this specific Output in its parent Transaction
 * @property {string} scriptPubKey - The Script Public Key Hash
 * @property {number} amount - Amount (in whole Coin) of this Output
 * @property {number} satoshis - Amount in Satoshis of this Output
 * @property {number} height - The Blockheight the Parent Transaction was confirmed in
 * @property {number} confirmations - The total number of Confirmations the Parent Transaction has recieved
 * @example
 * { 
 * 	address: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
 * 	txid: '7687e361f00998f96b29938bf5b7d9003a15ec182c13b6ddbd5adc0f993cbf9c',
 * 	vout: 1,
 * 	scriptPubKey: '76a9141bfcff1731caf3a16225d3e78735ddc229e4fc6c88ac',
 * 	amount: 0.001,
 * 	satoshis: 100000,
 * 	height: 2784696,
 * 	confirmations: 6828 
 * }
 */

/**
 * Contains information about an Unspent Transaction Output
 * @typedef {Object} AddressState
 * @property {string} addrStr - Base58 Public Address
 * @property {number} balanceSat - Balance of the Address in Satoshis
 * @property {number} totalReceivedSat - Total Recieved to the Address in Satoshis
 * @property {number} unconfirmedBalanceSat - Unconfirmed Balance of the Address in Satoshis
 * @property {Array.<string>} transactions - Array of `txids` that have been confirmed on the Network
 * @property {Array.<string>} spentTransactions - Array of `txids` that have been spent, but not yet confirmed on the Network
 * @property {number} lastUpdated - Timestamp of when the Address was last updated/synced with the Explorer
 * @example
 * { 
 * 	addrStr: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
 * 	balanceSat: 0,
 * 	totalReceivedSat: 0,
 * 	unconfirmedBalanceSat: 0,
 * 	transactions: [],
 * 	spentTransactions: [],
 * 	lastUpdated: 0 
 * }
 */

/**
 * Manages information about a specific Address
 */

var Address = function () {
	/**
  * Create a new Address based on either a bip32 node, WIF Private Key, or Public Address
  * ##### Examples
  * Create Address from bip32
  * ```
  * import bip32 from 'bip32';
  * import { Address, Networks } from 'oip-hdmw';
  *
  * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
  * var address = new Address(node, Networks.flo);
  * ```
  * Create Address from WIF
  * ```
  * import { Address, Networks } from 'oip-hdmw';
  *
  * var address = new Address("RAtKUeXYMEHEFkhbJuXGMEQZsqgHosnP2BLVaLWMRswWrcCNbZk5", Networks.flo);
  * ```
  * Create Address from Base58 Public Address
  * ```
  * import { Address, Networks } from 'oip-hdmw';
  *
  * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo);
  * ```
  * @param  {bip32|string} address - The Public Address, Private Key (WIF), or bip32 Node that the Address is for.
  * @param  {CoinInfo} coin - CoinInfo for the specific Address
  * @param  {boolean|AddressState} [discover=true] - Either a `boolean` value for if the Address should auto-discover, or an AddressState object to load the Internal state from.
  * @return {Address}
  */
	function Address(address, coin, discover) {
		_classCallCheck(this, Address);

		if (address.network !== undefined) {
			this.fromBIP32 = true;

			if (address.address) {
				this.address = address.address;
			} else if (address.index !== undefined && address.depth !== undefined) {
				this.address = address;
			}

			// Make sure that the networks match and throw an error if they don't
			if (address.network.pubKeyHash !== coin.network.pubKeyHash) {
				throw new Error("Address Network and Coin Network DO NOT MATCH!!!!!");
			}
		} else {
			if ((0, _util.isValidPublicAddress)(address, coin.network)) {
				this.fromBIP32 = false;
				this.pubAddress = address;
			} else if ((0, _util.isValidWIF)(address, coin.network)) {
				this.fromBIP32 = true;

				this.address = ECPair.fromWIF(address, coin.network);
			}
		}

		this.coin = coin || { satPerCoin: 1e8

			// Setup internal variables
		};this.transactions = [];

		this.balanceSat = 0;
		this.totalReceivedSat = 0;
		this.totalSentSat = 0;
		this.unconfirmedBalanceSat = 0;

		this.lastUpdated = 0;

		this.spentTransactions = [];

		// Setup EventEmitter to notify when we have changed
		this.event_emitter = new _eventemitter2.default();

		// Setup Websocket Address updates to keep us always up to date
		this.coin.explorer.onAddressUpdate(this.getPublicAddress(), this._processWebsocketUpdate.bind(this));

		if (discover || discover === false) {
			// Load from serialized JSON
			this.deserialize(discover);
		} else {
			// Update the state from the explorer
			this.updateState();
		}
	}
	/**
  * Get the Base58 sharable Public Address
  * @example
  * import { Address, Networks } from 'oip-hdmw';
  * 
  * var address = new Address("RAtKUeXYMEHEFkhbJuXGMEQZsqgHosnP2BLVaLWMRswWrcCNbZk5", Networks.flo);
  * var pubAddr = address.getPublicAddress();
  * // pubAddr = F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
  * @return {string}
  */


	_createClass(Address, [{
		key: 'getPublicAddress',
		value: function getPublicAddress() {
			var public_key;

			if (this.fromBIP32 && this.address) {
				public_key = this.address.publicKey;

				if (!public_key && this.address.getPublicKeyBuffer) public_key = this.address.getPublicKeyBuffer();
			}

			return this.fromBIP32 ? (0, _util.toBase58)(public_key, this.coin.network.pubKeyHash) : this.pubAddress;
		}
		/**
   * Get the Base58 sharable Private Address (WIF)
   * @example
   * import bip32 from 'bip32';
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo);
   * var wif = address.getPrivateAddress();
   * // wif = RAtKUeXYMEHEFkhbJuXGMEQZsqgHosnP2BLVaLWMRswWrcCNbZk5
   * @return {string}
   */

	}, {
		key: 'getPrivateAddress',
		value: function getPrivateAddress() {
			return this.address ? this.address.toWIF() : undefined;
		}
		/**
   * Get the internal ECPair. This is used when you need to Sign Transactions, or to access the raw public/private Buffers. 
   * Please note that if you create the Address from a Public Key, you will not get back an ECPair, since we need access 
   * to the Private Key in order to create/access the ECPair. When Address is created using a bip32 node or a Private Key (WIF)
   * the ECPair will exist.
   * @example
   * import bip32 from 'bip32';
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo);
   * var ecpair = address.getECPair();
   * @return {ECPair}
   */

	}, {
		key: 'getECPair',
		value: function getECPair() {
			return this.address;
		}
		/**
   * Get the signature of a specific message that can be verified by others
   * @param  {String} message - The message you wish to get the signature for
   * @return {String} Returns the base64 string of the created Signature
   */

	}, {
		key: 'signMessage',
		value: function signMessage(message) {
			if (!message || typeof message !== "string") throw new Error("Message must be defined and a String!");

			var privatekey_ecpair = this.getECPair();

			if (!privatekey_ecpair) throw new Error("No Private Key available! Unable to sign message!");

			var privateKeyBuffer = privatekey_ecpair.privateKey;

			var compressed = privatekey_ecpair.compressed || true;
			var messagePrefix = this.coin.network.messagePrefix;

			var signature_buffer = void 0;
			try {
				signature_buffer = _bitcoinjsMessage2.default.sign(message, privateKeyBuffer, compressed, messagePrefix);
			} catch (e) {
				throw new Error("Unable to create signature! \n" + e);
			}

			return signature_buffer.toString('base64');
		}
		/**
   * Verify the signature of a given message
   * @param  {String} message   - The message you want to verify
   * @param  {String} signature - The signature of the message
   * @return {Boolean} Returns either `true` or `false` depending on if the signature and message match
   */

	}, {
		key: 'verifySignature',
		value: function verifySignature(message, signature) {
			var valid = void 0;

			try {
				valid = _bitcoinjsMessage2.default.verify(message, this.getPublicAddress(), signature, this.coin.network.messagePrefix);
			} catch (e) {
				throw new Error("Unable to verify signature! \n" + e);
			}

			return valid;
		}
		/**
   * Get the latest State for this address from the Blockchain Explorer
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo);
   * address.updateState().then((addr) => {
   * 	console.log(addr.getTotalReceived())
   * })
   * @return {Promise<Address>} Returns a Promise that will resolve to the Address
   */

	}, {
		key: 'updateState',
		value: async function updateState() {
			try {
				var state = await this.coin.explorer.getAddress(this.getPublicAddress());
			} catch (e) {
				throw new Error("Error Updating Address State for: " + this.getPublicAddress() + "\n" + e);
			}

			return this.deserialize(state);
		}
		/**
   * Hydrate an Address from the serialized JSON, or update the state
   * @param  {AddressState} state
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * 
   * address.deserialize({ 
   * 	addrStr: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
      * 	balanceSat: 123,
      * 	totalReceivedSat: 234,
      * 	unconfirmedBalanceSat: 345,
      * 	transactions: ['abcde'],
      * 	spentTransactions: ['bcdef'],
      * 	lastUpdated: 456 
      * })
      *
      * var balance = address.getBalance()
      * // balance = 0.00000123
   * @return {Address}
   */

	}, {
		key: 'deserialize',
		value: function deserialize(state) {
			if (!state) return;

			// If the state doesn't match for this address, ignore it.
			if (state.addrStr && state.addrStr !== this.getPublicAddress()) return;

			if (!isNaN(state.balanceSat)) this.balanceSat = state.balanceSat;

			if (!isNaN(state.totalReceivedSat)) this.totalReceivedSat = state.totalReceivedSat;

			if (!isNaN(state.totalSentSat)) this.totalSentSat = state.totalSentSat;

			if (!isNaN(state.unconfirmedBalanceSat)) this.unconfirmedBalanceSat = state.unconfirmedBalanceSat;

			if (Array.isArray(state.transactions)) {
				this.transactions = state.transactions;
			}

			if (Array.isArray(state.spentTransactions)) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = state.spentTransactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var tx = _step.value;

						this.spentTransactions.push(tx);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			if (!isNaN(state.lastUpdated)) this.lastUpdated = state.lastUpdated;else this.lastUpdated = Date.now();

			return this;
		}
		/**
   * Get a serialized version of the Address (dried out JSON)
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   *
   * var address_state = address.serialize()
   * // address_state = { 
   * // 	addrStr: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
      * // 	balanceSat: 0,
      * // 	totalReceivedSat: 0,
      * // 	unconfirmedBalanceSat: 0,
      * // 	transactions: [],
      * // 	spentTransactions: [],
      * // 	lastUpdated: 0 
      * // }
   * @return {AddressState}
   */

	}, {
		key: 'serialize',
		value: function serialize() {
			return {
				addrStr: this.getPublicAddress(),
				wif: this.getPrivateAddress(),
				balanceSat: this.balanceSat,
				totalReceivedSat: this.totalReceivedSat,
				unconfirmedBalanceSat: this.unconfirmedBalanceSat,
				transactions: this.transactions,
				spentTransactions: this.spentTransactions,
				lastUpdated: this.lastUpdated
			};
		}
		/**
   * Get the Balance (in whole coins) for the Address
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * var balance = address.getBalance();
   * // balance = 0
   * @return {number}
   */

	}, {
		key: 'getBalance',
		value: function getBalance() {
			return this.balanceSat / this.coin.satPerCoin;
		}
		/**
   * Get the Total Recieved balance (in whole coins) for the Address
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * var totReceived = address.getTotalReceived();
   * // totReceived = 0
   * @return {number}
   */

	}, {
		key: 'getTotalReceived',
		value: function getTotalReceived() {
			return this.totalReceivedSat / this.coin.satPerCoin;
		}
		/**
   * Get the Total Sent balance (in whole coins) for the Address
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * var totSent = address.getTotalSent();
   * // totSent = 0
   * @return {number}
   */

	}, {
		key: 'getTotalSent',
		value: function getTotalSent() {
			return this.totalSentSat / this.coin.satPerCoin;
		}
		/**
   * Get the Unconfirmed Balance (in whole coins) for the Address
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * var uBal = address.getUnconfirmedBalance();
   * // uBal = 0
   * @return {number}
   */

	}, {
		key: 'getUnconfirmedBalance',
		value: function getUnconfirmedBalance() {
			return this.unconfirmedBalanceSat / this.coin.satPerCoin;
		}
		/**
   * Get the unspent transaction outputs for the Address
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * address.getUnspent().then((utxos) => {
   * 	console.log(utxos);
   * })
   * @return {Promise<Array.<utxo>>} Returns a Promise that resolves to an Array of utxos.
   */

	}, {
		key: 'getUnspent',
		value: function getUnspent() {
			var _this = this;

			return this.coin.explorer.getAddressUtxo(this.getPublicAddress()).then(function (utxos) {
				return _this.removeSpent(utxos);
			});
		}
		/**
   * Remove the already spent outputs from the array we are given.
   * @param  {Array.<utxo>} unspentTransactions - An Array containing utxos to sort through
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * address.getUnspent().then((utxos) => {
   * 	var unspent_utxos = address.removeSpent(utxos)
   * 	console.log(unspent_utxos)
   * })
   * @return {Array.<utxo>}
   */

	}, {
		key: 'removeSpent',
		value: function removeSpent(unspentTransactions) {
			// If we are not defined, or we are not an array, just return
			if (!unspentTransactions || !Array.isArray(unspentTransactions)) return;

			var unspent = [];

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = unspentTransactions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var tx = _step2.value;

					var spent = false;
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this.spentTransactions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var txid = _step3.value;

							if (txid === tx.txid) {
								spent = true;
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}

					if (!spent) unspent.push(tx);
				}

				// @ToDo: Check if some spentTransactions txids are missing from the unspentTransactions array
				// If the txid is missing from the unspentTransactions array, then remove it from the spentTransactions array
				// This clears out any spentTransactions that have been confirmed as no longer unspent.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return unspent;
		}
		/**
   * Add a TXID to the local Spent Transactions of the Address to prevent a specific output from being doublespent.
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * address.addSpentTransaction("7687e361f00998f96b29938bf5b7d9003a15ec182c13b6ddbd5adc0f993cbf9c")
   * @param {string} txid - The TXID of the spent output that we should remove
   */

	}, {
		key: 'addSpentTransaction',
		value: function addSpentTransaction(txid) {
			this.spentTransactions.push(txid);
		}
		/**
   * Internal function used to process updates streaming in from Websockets,
   * emits an update that can be subscribed to with onWebsocketUpdate
   * @param  {Object} update - Websocket Update Data
   */

	}, {
		key: '_processWebsocketUpdate',
		value: function _processWebsocketUpdate(update) {
			// If there is no data available, just ignore it
			if (!update) return;

			// If there is updated data, go ahead and set ourselves to it
			if (update.updated_data) {
				var addr = this.deserialize(update.updated_data);
				this.event_emitter.emit("websocket_update", addr);
			}
		}
		/**
   * Subscribe to events that are emitted when an Address update is recieved via Websockets
   * @param  {function} subscriber_function - The function you want called when there is an update
   *
   * @example
   * import { Address, Networks } from 'oip-hdmw';
   *
   * var address = new Address("F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp", Networks.flo, false);
   * address.onWebsocketUpdate((address) => {
   * 		console.log(address.getPublicAddress() + " Recieved a Websocket Update!")
   * })
   */

	}, {
		key: 'onWebsocketUpdate',
		value: function onWebsocketUpdate(subscriber_function) {
			this.event_emitter.on("websocket_update", subscriber_function);
		}
	}]);

	return Address;
}();

module.exports = Address;