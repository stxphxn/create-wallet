'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _bip = require('bip32');

var _bip2 = _interopRequireDefault(_bip);

var _bip32Utils = require('bip32-utils');

var _bip32Utils2 = _interopRequireDefault(_bip32Utils);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

var _TransactionBuilder = require('./TransactionBuilder');

var _TransactionBuilder2 = _interopRequireDefault(_TransactionBuilder);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Helper CONSTS (used in other consts)
var SECOND = 1000;
var MINUTE = 60 * SECOND;

// Class Constants
var CHAIN_EXPIRE_TIMEOUT = 30 * MINUTE;
var GAP_LIMIT = 20;

var CUSTOM_ADDRESS_FUNCTION = function CUSTOM_ADDRESS_FUNCTION(node, network) {
	return { address: node, network: network };
};

/**
 * A BIP32 Node that manages Derivation of Chains and Addresses. This is created from the [`bip32` npm package managed by `bitcoinjs`](https://github.com/bitcoinjs/bip32).
 * @typedef {Object} bip32
 * @example <caption>Spawn a Bitcoin bip32 Node</caption>
 * import bip32 from 'bip32';
 * 
 * var bip32Node = bip32.fromBase58("xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb")
 * @example <caption>Spawn a Flo bip32 Node</caption>
 * import bip32 from 'bip32';
 * import { Networks } from 'oip-hdmw';
 * 
 * var bip32Node = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
 */

/**
 * A BIP32 Chain manager. This is created from the [`bip32-utils` npm package managed by `bitcoinjs`](https://github.com/bitcoinjs/bip32-utils).
 * @typedef {Object} bip32utilschain
 * @example
 * import bip32 from 'bip32';
 * import bip32utils from 'bip32-utils';
 * 
 * var bip32Node = bip32.fromBase58("xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb")
 * var chain = new bip32utils.Chain(bip32Node)
 */

/**
 * Manages Chains and Addresses for a specific BIP32/BIP44 Account
 */

var Account = function () {
	/**
  * Create a new Account to manage Chains and Addresses for based on a BIP32 Node
  *
  * ##### Examples
  * Create a Bitcoin Account
  * ```
  * import { Account, Networks } from 'oip-hdmw';
  *
  * var account_master = bip32.fromBase58("xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb")
  *
  * var account = new Account(account_master, Networks.bitcoin);
  * ```
  * Create a Flo Account
  * ```
  * import { Account, Networks } from 'oip-hdmw';
  *
  * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
  *
  * var account = new Account(account_master, Networks.flo);
  * ```
  * @param  {bip32} account_master - The BIP32 Node to derive Chains and Addresses from.
  * @param  {CoinInfo} coin - The CoinInfo for the Account
  * @param {Object} [options] - The Options of the Account
  * @param  {boolean} [options.discover=true] - Should the Account auto-discover Chains and Addresses
  * @param {Object} [options.serialized_data] - Serialized data to load the Account from
  * @return {Account}
  */
	function Account(account_master, coin, options) {
		_classCallCheck(this, Account);

		this.account_master = account_master;
		this.coin = coin || {};

		var external = this.account_master.derive(0);
		var internal = this.account_master.derive(1);

		this.account = new _bip32Utils2.default.Account([new _bip32Utils2.default.Chain(external, undefined, CUSTOM_ADDRESS_FUNCTION), new _bip32Utils2.default.Chain(internal, undefined, CUSTOM_ADDRESS_FUNCTION)]);

		this.addresses = {};

		this.chains = {
			0: {
				index: 0,
				lastUpdate: 0
			},
			1: {
				index: 1,
				lastUpdate: 0
			}

			// Setup EventEmitter to notify when we have changed
		};this.event_emitter = new _eventemitter2.default();

		this.discover = true;

		if (options && options.discover !== undefined) this.discover = options.discover;

		// Discover both External and Internal chains
		if (options && options.serialized_data) this.deserialize(options.serialized_data);

		if (this.discover) {
			this.discoverChains();
		}
	}

	_createClass(Account, [{
		key: 'serialize',
		value: function serialize() {
			var addresses = this.getAddresses();

			var serialized_addresses = addresses.map(function (address) {
				return address.serialize();
			});

			return {
				extended_private_key: this.getExtendedPrivateKey(),
				addresses: serialized_addresses,
				chains: this.chains
			};
		}
	}, {
		key: 'deserialize',
		value: function deserialize(serialized_data) {
			if (serialized_data) {
				// Rehydrate Addresses
				if (serialized_data.addresses) {
					var rehydrated_addresses = [];

					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = serialized_data.addresses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var address = _step.value;

							rehydrated_addresses.push(new _Address2.default(address.wif, this.coin, address));
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}

					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = rehydrated_addresses[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var _address = _step2.value;

							this.addresses[_address.getPublicAddress()] = _address;
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
				// Rehydrate Chain info
				if (serialized_data.chains) {
					this.chains = serialized_data.chains;
				}
			}
		}
		/**
   * Get the Main Address for a specified Chain and Index on the Chain.
   * @param  {number}	[chain_number=0] - Number of the specific chain you want to get the Main Address for
   * @param  {number} [main_address_number=0] - Index of the Main Address on the specified chain
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var address = account.getMainAddress()
   * // address.getPublicAddress() = FPznv9i9iHX5vt4VMbH9x2LgUcrjtSn4cW
   * @return {Address}
   */

	}, {
		key: 'getMainAddress',
		value: function getMainAddress(chain_number, main_address_number) {
			return this.getAddress(chain_number, main_address_number);
		}
		/**
   * Get the Address for a specified Chain and Index on the Chain.
   * @param  {number}	[chain_number=0] - Number of the specific chain you want to get the Address from
   * @param  {number} [address_number=0] - Index of the Address on the specified chain
   * @example <caption>Get the address on Chain `0` at Index `10`</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var address = account.getAddress(0, 10)
   * // address.getPublicAddress() = F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
   * @return {Address}
   */

	}, {
		key: 'getAddress',
		value: function getAddress(chain_number, address_number) {
			var addr = CUSTOM_ADDRESS_FUNCTION(this.account.getChain(chain_number || 0).__parent.derive(address_number || 0), this.coin.network);

			var tmpHydratedAddr = new _Address2.default(addr, this.coin, false);

			// Attempt to match to address that we already have
			if (this.addresses[tmpHydratedAddr.getPublicAddress()]) return this.addresses[tmpHydratedAddr.getPublicAddress()];else this.addresses[tmpHydratedAddr.getPublicAddress()] = tmpHydratedAddr;

			return tmpHydratedAddr;
		}
		/**
   * Get all derived Addresses for the entire Account, or just for a specific Chain.
   * @param  {number}	[chain_number] - Number of the specific chain you want to get the Addresses from
   * @example <caption>Get all Addresses on the Account</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var addresses = account.getAddresses()
   * // addresses = [Address, Address, Address]
   * @example <caption>Get the addresses on Chain `0`</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var addresses = account.getAddresses(0)
   * // addresses = [Address, Address, Address]
   * @return {Array.<Address>}
   */

	}, {
		key: 'getAddresses',
		value: function getAddresses(chain_number) {
			var _this = this;

			var addrs = [];

			if (chain_number && typeof chain_number === "number") {
				for (var addr in this.addresses) {
					var chain = this.account.getChain(chain_number);
					var addresses = chain.addresses.map(function (ad) {
						return new _Address2.default(ad, _this.coin, false);
					});
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = addresses[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var adr = _step3.value;

							if (adr.getPublicAddress() === this.addresses[addr].getPublicAddress()) {
								addrs.push(this.addresses[addr]);
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}
			} else {
				for (var addr in this.addresses) {
					addrs.push(this.addresses[addr]);
				}
			}

			return addrs;
		}
		/**
   * Get all Used Addresses (addresses that have recieved at least 1 tx) for the entire Account, or just for a specific Chain.
   * @param  {number}	[chain_number] - Number of the specific chain you want to get the Addresses from
   * @example <caption>Get all Used Addresses on the Account</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var addresses = account.getUsedAddresses()
   * // addresses = [Address, Address, Address]
   * @example <caption>Get the addresses on Chain `0`</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var addresses = account.getUsedAddresses(0)
   * // addresses = [Address, Address, Address]
   * @return {Array.<Address>}
   */

	}, {
		key: 'getUsedAddresses',
		value: function getUsedAddresses(chain_number) {
			var used_addresses = [];
			var all_addresses = this.getAddresses();

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = all_addresses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var address = _step4.value;

					if (address.getTotalReceived() > 0) used_addresses.push(address);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			return used_addresses;
		}
		/**
   * Get the Balance for the entire Account
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * account.getBalance({ discover: true }).then((balance) => {
   * 	console.log(balance);
   * })
   * @param {Object} [options] Specific options defining what balance to get back
   * @param {Boolean} [options.discover=true] - Should the Account discover Chains and Addresses
   * @param {string|Array.<string>} [options.addresses] - Address, or Addresses to get the balance of
   * @param {number} [options.id] - The ID number to return when the Promise resolves
   * @return {Promise<number>} - Returns a Promise that will resolve to the total balance.
   */

	}, {
		key: 'getBalance',
		value: async function getBalance(options) {
			var discover = this.discover;

			if (options && options.discover !== undefined) discover = options.discover;

			if (discover) {
				try {
					await this.discoverChains();
				} catch (e) {
					throw new Error("Unable to discover Account Chains in Account getBalance! \n" + e);
				}
			}

			var totalBal = 0;

			// Iterate through each of the addresses we have found
			for (var addr in this.addresses) {
				// Are we searching only for a single addresses balance?
				if (options && options.addresses && typeof options.addresses === "string") {
					if (addr === options.addresses) {
						totalBal += this.addresses[addr].getBalance();
					}
					// Are we searching for only the addresses in an array?
				} else if (options && options.addresses && Array.isArray(options.addresses)) {
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;

					try {
						for (var _iterator5 = options.addresses[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var ad = _step5.value;

							if (addr === ad) {
								totalBal += this.addresses[addr].getBalance();
							}
						}
						// If not the first two, then just add them all up :)
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5.return) {
								_iterator5.return();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}
				} else {
					totalBal += this.addresses[addr].getBalance();
				}
			}

			var balance_data = {
				balance: totalBal
			};

			if (options && options.id) balance_data.id = options.id;

			return balance_data;
		}
		/**
   * Get the Next Chain Address for a specified chain
   * @param  {number} [chain_number=0] - The specific chain that you want to get the next address from
   * @example <caption>Get the next Chain Address on Chain #1</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var address = account.getNextChainAddress(1)
   * @return {Address}
   */

	}, {
		key: 'getNextChainAddress',
		value: function getNextChainAddress(chain_number) {
			return new _Address2.default(this.account.getChain(chain_number || 0).next(), this.coin, false);
		}
		/**
   * Get the Next Change Address from the "Internal" chain
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var address = account.getNextChangeAddress()
   * @return {Address}
   */

	}, {
		key: 'getNextChangeAddress',
		value: function getNextChangeAddress() {
			// We use Chain 1 since that is the "Internal" chain used for generating change addresses.
			return this.getNextChainAddress(1);
		}
		/**
   * Send a Payment to specified Addresses and Amounts
   * @param  {Object} options - the options for the specific transaction being sent
   * @param {OutputAddress|Array.<OutputAddress>} options.to - Define outputs for the Payment
   * @param {string|Array.<string>} [options.from=All Addresses in Account] - Define what public address(es) you wish to send from
   * @param {Boolean} [options.discover=true] - Should discovery happen before sending payment
   * @param {string} [options.floData=""] - Flo data to attach to the transaction
   * @return {Promise<string>} - Returns a promise that will resolve to the success TXID
   */

	}, {
		key: 'sendPayment',
		value: function sendPayment(options) {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				if (!options) reject(new Error("You must define your payment options!"));

				var processPayment = function processPayment() {
					var sendFrom = [];

					var allAddresses = _this2.getAddresses();

					// Check if we define what address we wish to send from
					if (options.from) {
						if (typeof options.from === "string") {
							var _iteratorNormalCompletion6 = true;
							var _didIteratorError6 = false;
							var _iteratorError6 = undefined;

							try {
								for (var _iterator6 = allAddresses[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
									var address = _step6.value;

									if (address.getPublicAddress() === options.from) {
										sendFrom.push(address);
									}
								}
							} catch (err) {
								_didIteratorError6 = true;
								_iteratorError6 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion6 && _iterator6.return) {
										_iterator6.return();
									}
								} finally {
									if (_didIteratorError6) {
										throw _iteratorError6;
									}
								}
							}
						} else if (Array.isArray(options.from)) {
							var _iteratorNormalCompletion7 = true;
							var _didIteratorError7 = false;
							var _iteratorError7 = undefined;

							try {
								for (var _iterator7 = options.from[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
									var adr = _step7.value;
									var _iteratorNormalCompletion8 = true;
									var _didIteratorError8 = false;
									var _iteratorError8 = undefined;

									try {
										for (var _iterator8 = allAddresses[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
											var address = _step8.value;

											if (address.getPublicAddress() === adr) {
												sendFrom.push(address);
											}
										}
									} catch (err) {
										_didIteratorError8 = true;
										_iteratorError8 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion8 && _iterator8.return) {
												_iterator8.return();
											}
										} finally {
											if (_didIteratorError8) {
												throw _iteratorError8;
											}
										}
									}
								}
							} catch (err) {
								_didIteratorError7 = true;
								_iteratorError7 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion7 && _iterator7.return) {
										_iterator7.return();
									}
								} finally {
									if (_didIteratorError7) {
										throw _iteratorError7;
									}
								}
							}
						}
						// else add all the addresses on the Account that have recieved any txs
					} else {
						var _iteratorNormalCompletion9 = true;
						var _didIteratorError9 = false;
						var _iteratorError9 = undefined;

						try {
							for (var _iterator9 = allAddresses[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
								var _address2 = _step9.value;

								if (_address2.getBalance() >= 0) {
									sendFrom.push(_address2);
								}
							}
						} catch (err) {
							_didIteratorError9 = true;
							_iteratorError9 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion9 && _iterator9.return) {
									_iterator9.return();
								}
							} finally {
								if (_didIteratorError9) {
									throw _iteratorError9;
								}
							}
						}
					}

					if (sendFrom.length === 0) {
						reject(new Error("No Addresses match defined options.from Addresses!"));
						return;
					}

					var newOpts = options;

					newOpts.from = sendFrom;

					var txb = new _TransactionBuilder2.default(_this2.coin, newOpts);

					txb.sendTX().then(resolve);
				};

				if (options.discover === false) {
					processPayment();
				} else {
					_this2.discoverChains().then(processPayment);
				}
			});
		}
		/**
   * Get the Extended Private Key for the Account
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var extPrivateKey = account.getExtendedPrivateKey()
   * // extPrivateKey = Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC
   * @return {string}
   */

	}, {
		key: 'getExtendedPrivateKey',
		value: function getExtendedPrivateKey() {
			return this.account_master.toBase58();
		}
		/**
   * Get the Extended Public Key for the Account
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var extPublicKey = account.getExtendedPublicKey()
   * // extPublicKey = Fpub1BPo8vEQqDkoDQmDqcJ8WFHD331AMpd7VU7atCJsix8xbHwN6K9wfDLjZKnW9fUw5uJg8UJMLhQ5W7gTxv6DbkfPoeJbBpMaUHrULxzVnSy
   * @return {string}
   */

	}, {
		key: 'getExtendedPublicKey',
		value: function getExtendedPublicKey() {
			return this.account_master.neutered().toBase58();
		}
		/**
   * Get the specified Chain number
   * @param {number} chain_number - The number of the chain you are requesting
   * @example <caption>Get Chain 0</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * var chain = account.getChain(0)
   * @return {bip32utilschain}
   */

	}, {
		key: 'getChain',
		value: function getChain(chainNumber) {
			return this.account.getChain(chainNumber);
		}
	}, {
		key: '_discoverChain',
		value: async function _discoverChain(chainNumber, gapLimit) {
			var chains = this.account.getChains();
			var chain = chains[chainNumber].clone();

			var discovered;

			try {
				discovered = await (0, _util.discovery)(chain, gapLimit, this._chainPromise, chainNumber, this.coin);
			} catch (e) {
				throw new Error("Discovery error in _discoverChain #" + chainNumber + " \n" + e);
			}

			// throw away EACH unused address AFTER the last unused address
			var unused = discovered.checked - discovered.used;
			for (var j = 1; j < unused; ++j) {
				chain.pop();
			} // override the internal chain
			this.account.chains[discovered.chainIndex] = chain;

			var _iteratorNormalCompletion10 = true;
			var _didIteratorError10 = false;
			var _iteratorError10 = undefined;

			try {
				for (var _iterator10 = discovered.addresses[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
					var address = _step10.value;

					this.addresses[address.getPublicAddress()] = address;
				}
			} catch (err) {
				_didIteratorError10 = true;
				_iteratorError10 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion10 && _iterator10.return) {
						_iterator10.return();
					}
				} finally {
					if (_didIteratorError10) {
						throw _iteratorError10;
					}
				}
			}

			return discovered;
		}
	}, {
		key: '_chainPromise',
		value: async function _chainPromise(addresses, coin) {
			var results = {};
			var allAddresses = [];

			var addressPromises = [];

			var _iteratorNormalCompletion11 = true;
			var _didIteratorError11 = false;
			var _iteratorError11 = undefined;

			try {
				for (var _iterator11 = addresses[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
					var addr = _step11.value;

					var address = new _Address2.default(addr, coin, false);

					var prom = address.updateState();

					// This will only be called for any rejections AFTER the first one,
					// please take a look at the comment below for more info.
					prom.catch(function (e) {});

					addressPromises.push(address.updateState());
				}
			} catch (err) {
				_didIteratorError11 = true;
				_iteratorError11 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion11 && _iterator11.return) {
						_iterator11.return();
					}
				} finally {
					if (_didIteratorError11) {
						throw _iteratorError11;
					}
				}
			}

			var promiseResponses = [];

			try {
				promiseResponses = await Promise.all(addressPromises);
			} catch (e) {
				// This will still be called even though we use prom.catch() above.
				// The first promise rejection will be caught here, all other promises
				// that reject AFTER the first, will be caught in the above prom.catch() function.

				throw new Error("Unable to update Address state in _chainPromise \n" + e);
			}

			var _iteratorNormalCompletion12 = true;
			var _didIteratorError12 = false;
			var _iteratorError12 = undefined;

			try {
				for (var _iterator12 = promiseResponses[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
					var address = _step12.value;

					if (address.getTotalReceived() > 0) {
						results[address.getPublicAddress()] = true;
					} else {
						results[address.getPublicAddress()] = false;
					}

					// Store all addresses
					allAddresses.push(address);
				}
			} catch (err) {
				_didIteratorError12 = true;
				_iteratorError12 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion12 && _iterator12.return) {
						_iterator12.return();
					}
				} finally {
					if (_didIteratorError12) {
						throw _iteratorError12;
					}
				}
			}

			return { results: results, addresses: allAddresses };
		}
		/**
   * Discover Used and Unused addresses for a specified Chain number
   * @param  {number} chain_number - The number of the chain you wish to discover
   * @example <caption>Discover Chain 0</caption>
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * account.discoverChain(0).then((acc) => {
   * 	console.log(acc.getChain(0).addresses)
   * })
   * @return {Promise<Account>} - A Promise that once finished will resolve to the Account (now with discovery done)
   */

	}, {
		key: 'discoverChain',
		value: async function discoverChain(chain_number) {
			try {
				var discovered = await this._discoverChain(chain_number, GAP_LIMIT);
			} catch (e) {
				throw new Error("Unable to discoverChain #" + chain_number + "! \n" + e);
			}

			this.chains[chain_number] = { lastUpdate: Date.now() };

			return this;
		}
		/**
   * Discover all Chains
   * @example
   * import bip32 from 'bip32'
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * account.discoverChains().then((acc) => {
   * 	console.log(acc.getChain(0).addresses)
   * 	console.log(acc.getChain(1).addresses)
   * })
   * @return {Promise<Account>} - A Promise that once finished will resolve to the Account (now with discovery done)
   */

	}, {
		key: 'discoverChains',
		value: async function discoverChains() {
			var chainsToDiscover = [0, 1];

			var account;

			// Do each chain one at a time in case it crashes and errors out.
			var _iteratorNormalCompletion13 = true;
			var _didIteratorError13 = false;
			var _iteratorError13 = undefined;

			try {
				for (var _iterator13 = chainsToDiscover[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
					var c = _step13.value;

					try {
						account = await this.discoverChain(c);
					} catch (e) {
						throw new Error("Unable to discoverChains! \n" + e);
					}
				}
			} catch (err) {
				_didIteratorError13 = true;
				_iteratorError13 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion13 && _iterator13.return) {
						_iterator13.return();
					}
				} finally {
					if (_didIteratorError13) {
						throw _iteratorError13;
					}
				}
			}

			this._subscribeToAddressWebsocketUpdates();

			return account;
		}
		/**
   * Internal function used to subscribe to WebSocket updates for All Discovered Addresses
   */

	}, {
		key: '_subscribeToAddressWebsocketUpdates',
		value: function _subscribeToAddressWebsocketUpdates() {
			var allAddresses = this.getAddresses();

			var _iteratorNormalCompletion14 = true;
			var _didIteratorError14 = false;
			var _iteratorError14 = undefined;

			try {
				for (var _iterator14 = allAddresses[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
					var address = _step14.value;

					address.onWebsocketUpdate(this._handleWebsocketUpdate.bind(this));
				}
			} catch (err) {
				_didIteratorError14 = true;
				_iteratorError14 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion14 && _iterator14.return) {
						_iterator14.return();
					}
				} finally {
					if (_didIteratorError14) {
						throw _iteratorError14;
					}
				}
			}
		}
		/**
   * Internal function used to process Address updates streaming in from Websockets,
   * emits an update that can be subscribed to with onWebsocketUpdate
   * @param  {Object} update - Websocket Update Data
   */

	}, {
		key: '_handleWebsocketUpdate',
		value: function _handleWebsocketUpdate(address) {
			this.event_emitter.emit("websocket_update", address);
		}
		/**
   * Subscribe to events that are emitted when an Address update is recieved via Websocket
   * @param  {function} subscriber_function - The function you want called when there is an update
   *
   * @example
   * import { Account, Networks } from 'oip-hdmw'
   * 
   * var account_master = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", Networks.flo.network)
   *
   * var account = new Account(account_master, Networks.flo, false);
   * 
   * account.onWebsocketUpdate((address) => {
   * 		console.log(address.getPublicAddress() + " Recieved a Websocket Update!")
   * })
   */

	}, {
		key: 'onWebsocketUpdate',
		value: function onWebsocketUpdate(subscriber_function) {
			this.event_emitter.on("websocket_update", subscriber_function);
		}
	}]);

	return Account;
}();

module.exports = Account;