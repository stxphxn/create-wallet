'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _bip = require('bip32');

var _bip2 = _interopRequireDefault(_bip);

var _bip32Utils = require('bip32-utils');

var _bip32Utils2 = _interopRequireDefault(_bip32Utils);

var _coinselect = require('coinselect');

var _coinselect2 = _interopRequireDefault(_coinselect);

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

var _TransactionBuilderHelpers = require('./TransactionBuilderHelpers');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An Output for a Transaction
 * @typedef {Object} OutputAddress
 * @example
 * { "FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001 }
 * @example
 * { "base58-public-address": valueInWholeCoin }
 */

/**
 * An object returned from `coinselect` that contains information about selected inputs, outputs, and the fee.
 * @typedef {Object} SelectedInputOutput
 * @property {Array<TXInput>} inputs - An Array of Transaction Inputs
 * @property {Array<TXOutput>} outputs - An Array of Transaction Outputs
 * @property {number} fee - The Calculated Fee to pay
 */

/**
 * A Transaction Input
 * @typedef {Object} TXInput
 * @property {string} address - Base58 Public Address
 * @property {string} txId - Parent Transaction ID
 * @property {number} vout - Index of output in Parent Transaction
 * @property {string} scriptPubKey - Script Public Key Hash
 * @property {number} value - Balance of the input in Satoshis 
 * @example
 * { 
 * 	address: 'F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp',
 * 	txId: '7687e361f00998f96b29938bf5b7d9003a15ec182c13b6ddbd5adc0f993cbf9c',
 * 	vout: 1,
 * 	scriptPubKey: '76a9141bfcff1731caf3a16225d3e78735ddc229e4fc6c88ac',
 * 	value: 100000 
 * }
 */

/**
 * A Transaction Output
 * @typedef {Object} TXOutput
 * @property {string} address - Base58 Public Address
 * @property {number} value - Amount to send Satoshis 
 * @example
 * {
 * 	address: 'FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu',
 * 	value: 1000
 * }
 */

/**
 * Build & Send Transactions out to the network Easily using Addresses!
 */
var TransactionBuilder = function () {
	/**
  * Create a new TransactionBuilder
  * ##### Example
  * ```
  * import bip32 from 'bip32'
  * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
  * 
  * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
  * var address = new Address(node, Networks.flo, false)
  * 
  * var builder = new TransactionBuilder(Networks.flo, {
  * 	from: address,
  * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
  * 	floData: "Testing oip-hdmw!"
  * })
  * ```
  * @param  {CoinInfo} coin - CoinInfo for this specific Network you want to send the Transaction on.
  * @param  {Object} [options]
  * @param  {Address|Array.<Address>} options.from - The Address(es) to send from.
  * @param  {OutputAddress|Array.<OutputAddress>} options.to - The amounts & Address(es) to send to.
  * @param  {string} [options.floData=""] - The FloData to be added to the Transaction
  * @param  {Account} [account] - An Account to get a Change Address from if needed, if undefined, change will be sent to first `from` Address.
  * @return {TransactionBuilder}
  */
	function TransactionBuilder(coin, options, account) {
		_classCallCheck(this, TransactionBuilder);

		this.coin = coin;
		this.account = account;

		// Addresses we are sending from
		this.from = [];
		// Addresses we want to send to & amounts
		this.to = [];

		this.passedOptions = {};

		this.parseOptions(options);
	}
	/**
  * Add an Address to send from
  * @example
  * import bip32 from 'bip32'
  * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
  * 
  * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
  * var address = new Address(node, Networks.flo, false)
  *
  * var builder = new TransactionBuilder(Networks.flo)
  * builder.addFrom(address);
  * @param {Address} address - Address to add to the From Addresses
  */


	_createClass(TransactionBuilder, [{
		key: 'addFrom',
		value: function addFrom(address) {
			if (address instanceof _Address2.default) {
				if ((0, _util.isValidPublicAddress)(address.getPublicAddress(), this.coin.network)) {
					this.from.push(address);
				}
			} else {
				throw new Error("From Address MUST BE InstanceOf Address");
			}
		}
		/**
   * Add an Address and Amount to send to
   * @example
   * import bip32 from 'bip32'
   * import { TransactionBuilder, Networks } from 'oip-hdmw'
   *
   * var builder = new TransactionBuilder(Networks.flo)
   * builder.addTo("FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu", 0.001);
   * @param {string} address - Base58 Public Address to send To
   * @param {number} amount - Amount to Send (in whole coin)
   */

	}, {
		key: 'addTo',
		value: function addTo(address, amount) {
			if ((0, _util.isValidPublicAddress)(address, this.coin.network) && !isNaN(amount)) {
				var tmpTo = {
					address: address,
					value: amount
				};
				this.to.push(tmpTo);
			}
		}
		/**
   * Load From & To addresses
   * @param  {Object} options
   * @param  {Address|Array.<Address>} options.from - The Address(es) to send from.
   * @param  {OutputAddress|Array.<OutputAddress>} options.to - The amounts & Address(es) to send to.
   * @param  {string} [options.floData=""] - The FloData to be added to the Transaction
   * @example
   * import bip32 from 'bip32'
   * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
   * 
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo, false)
   * 
   * var builder = new TransactionBuilder(Networks.flo)
   * 
   * builder.parseOptions({
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
   * 	floData: "Testing oip-hdmw!"
   * })
   */

	}, {
		key: 'parseOptions',
		value: function parseOptions(options) {
			if (!options) return;

			// Grab the From Addresses, it can be an array or regular.
			if (options.from) {
				if (Array.isArray(options.from)) {
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = options.from[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var addr = _step.value;

							this.addFrom(addr);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				} else {
					this.addFrom(options.from);
				}
			}

			// Load who we are sending to
			if (options.to) {
				// Check if we are providing an address string and amount seperately
				if (Array.isArray(options.to)) {
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = options.to[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var payTo = _step2.value;

							for (var address in payTo) {
								this.addTo(address, payTo[address]);
							}
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				} else {
					for (var address in options.to) {
						this.addTo(address, options.to[address]);
					}
				}
			}

			this.passedOptions = options;
		}
		/**
   * Get the Unspent Transaction Outputs for all the From addresses specified.
   * @example
   * import bip32 from 'bip32'
   * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
   * 
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo, false)
   * 
   * var builder = new TransactionBuilder(Networks.flo, {
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
   * })
   *
   * builder.getUnspents().then((utxos) => {
   * 	console.log(utxos)
   * })
   * @return {Promise<Array.<utxo>>} Returns a Promise that will resolve to an Array of unspent utxos
   */

	}, {
		key: 'getUnspents',
		value: async function getUnspents() {
			var utxos = [];

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.from[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var addr = _step3.value;

					try {
						var tmp_utxos = await addr.getUnspent();

						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;

						try {
							for (var _iterator4 = tmp_utxos[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var utxo = _step4.value;

								utxos.push(utxo);
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4.return) {
									_iterator4.return();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
					} catch (e) {
						throw new Error("Unable to get Unspents \n" + e);
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return utxos;
		}
		/**
   * Get calculated Inputs and Outputs (and Fee) for From and To Addresses
   * @param {Array.<utxo>} [manual_utxos] - Pass in utxos for the function to use. If not passed, it will call the function getUnspents()
   * @example
   * import bip32 from 'bip32'
   * import { Account, Address, TransactionBuilder, Networks } from 'oip-hdmw'
   *
   * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
   * var account = new Account(accountMaster, networks.flo, false);
   * 
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo, false)
   * 
   * var builder = new TransactionBuilder(Networks.flo, {
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
   * }, account)
   *
   * builder.buildInputsAndOutputs().then((calculated) => {
   * 	console.log(calculated.inputs)
   * 	console.log(calculated.outputs)
   * 	console.log(calculated.fee)
   * })
   * @return {SelectedInputOutput} 
   */

	}, {
		key: 'buildInputsAndOutputs',
		value: async function buildInputsAndOutputs(manual_utxos) {
			var _this = this;

			try {
				await this.discoverChange();
			} catch (e) {
				throw new Error("Unable to Discover Change Addresses \n" + e);
			}

			var utxos = manual_utxos;

			if (!utxos) {
				try {
					utxos = await this.getUnspents();
				} catch (e) {
					throw new Error("Unable to get Unspents for Addresses \n" + e);
				}
			}

			var formattedUtxos = utxos.map(function (utxo) {
				return {
					address: utxo.address,
					txId: utxo.txid,
					vout: utxo.vout,
					scriptPubKey: utxo.scriptPubKey,
					value: utxo.satoshis,
					confirmations: utxo.confirmations
				};
			});

			var targets = this.to.map(function (toObj) {
				return {
					address: toObj.address,
					value: Math.floor(toObj.value * _this.coin.satPerCoin)
				};
			});

			var extraBytesLength = 0;
			var extraBytes = this.coin.getExtraBytes(this.passedOptions);

			if (extraBytes) extraBytesLength = extraBytes.length;

			var utxosNoUnconfirmed = formattedUtxos.filter(function (utx) {
				return utx.confirmations > 0;
			});

			var selected = (0, _coinselect2.default)(utxosNoUnconfirmed, targets, Math.ceil(this.coin.feePerByte), extraBytesLength);

			// Check if we are able to build inputs/outputs off only unconfirmed transactions with confirmations > 0
			if (selected.inputs && selected.inputs.length > 0 && selected.outputs && selected.outputs.length > 0 && selected.fee) return selected;else // else, build with the regular ones
				return (0, _coinselect2.default)(formattedUtxos, targets, Math.ceil(this.coin.feePerByte), extraBytesLength);
		}
		/**
   * Discover the used change addresses if we were passed an Account to discover from.
   * @example
   * import bip32 from 'bip32'
   * import { Account, Address, TransactionBuilder, Networks } from 'oip-hdmw'
   *
   * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
   * var account = new Account(accountMaster, networks.flo, false);
   * 
   * var node = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", Networks.flo.network)
   * var address = new Address(node, Networks.flo, false)
   * 
   * var builder = new TransactionBuilder(Networks.flo, {
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001}
   * }, account)
   * 
   * builder.discoverChange().then(() => {
   * 	console.log("Done Discovering Change!")
   * })
   * @return {Promise}
   */

	}, {
		key: 'discoverChange',
		value: async function discoverChange() {
			if (this.account) {
				try {
					await this.account.discoverChain(1);
					return;
				} catch (e) {
					throw new Error("Unable to Discover Chain \n" + e);
				}
			} else {
				return;
			}
		}
		/**
   * Build the Transaction hex for the From and To addresses
   * @param {SelectedInputOutput} [manual_selected] - Inputs and Outputs to use. If not passed, the function buildInputsAndOutputs() is run.
   * @example
   * import bip32 from 'bip32'
   * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
   * 
   * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
   * var account = new Account(accountMaster, networks.flo, false);
   * 
   * // F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
   * var addressNode = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", networks.flo.network)
   * var address = new Address(addressNode, networks.flo, false);
   * 
   * var builder = new TransactionBuilder(networks.flo, {
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
   * 	floData: "Testing oip-hdmw!"
   * }, account)
   * 
   * builder.buildTX().then((hex) => {
   * 	console.log(hex)
   * })
   * @return {Promise<string>} Returns a Promise that resolves to the calculated Transaction Hex
   */

	}, {
		key: 'buildTX',
		value: async function buildTX(manual_selected) {
			var _this2 = this;

			var selected = manual_selected;

			if (!selected) {
				try {
					selected = await this.buildInputsAndOutputs();
				} catch (e) {
					throw new Error("Unable to select inputs and outputs \n" + e);
				}
			}

			this.selected = selected;

			var inputs = selected.inputs;
			var outputs = selected.outputs;
			var fee = selected.fee;

			// inputs and outputs will be undefined if no solution was found
			if (!inputs || !outputs) {
				throw new Error("No Inputs or Outputs selected! Fail!");
			}

			var txb = new _bitcoinjsLib2.default.TransactionBuilder(this.coin.network);

			txb.setVersion(this.coin.txVersion);

			inputs.forEach(function (input) {
				return txb.addInput(input.txId, input.vout);
			});

			// Check if we are paying to ourself, if so, merge the outputs to just a single output.
			// Check if we only have one from address, and two outputs (i.e. pay to and change)
			if (this.from.length === 1 && outputs.length === 2) {
				// If the first input is sending to the from address, and there is a change output,
				// then merge the outputs.
				if (outputs[0].address === this.from[0].getPublicAddress() && !outputs[1].address) {
					var totalToSend = outputs[0].value + outputs[1].value;
					outputs = [{
						address: this.from[0].getPublicAddress(),
						value: totalToSend
					}];
				}
			}

			outputs.forEach(function (output) {
				// watch out, outputs may have been added that you need to provide
				// an output address/script for
				if (!output.address) {
					// Check if we have access to an account to get the change address from
					if (_this2.account) {
						output.address = _this2.account.getNextChangeAddress().getPublicAddress();
					} else {
						// If the change is undefined, send change to the first from address
						output.address = _this2.from[0].getPublicAddress();
					}
				}

				txb.addOutput(output.address, output.value);
			});

			for (var i in inputs) {
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;

				try {
					for (var _iterator5 = this.from[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var addr = _step5.value;

						if (addr.getPublicAddress() === inputs[i].address) {
							var _extraBytes = this.coin.getExtraBytes(this.passedOptions);

							if (_extraBytes) {
								(0, _TransactionBuilderHelpers.sign)(txb, _extraBytes, parseInt(i), addr.getECPair());
							} else {
								txb.sign(parseInt(i), addr.getECPair());
							}
						}
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5.return) {
							_iterator5.return();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
			}

			var builtHex = void 0;

			try {
				builtHex = txb.build().toHex();
			} catch (e) {
				throw new Error("Unable to build Transaction Hex! \n" + e);
			}

			var extraBytes = this.coin.getExtraBytes(this.passedOptions);

			if (extraBytes) builtHex += extraBytes;

			return builtHex;
		}
		/**
   * Build & Send the Transaction that we have been forming
   * @param {String} [manual_hex] - The hex you wish to send the tx for. If not used, the hex is grabbed from buildTX().
   * @example
   * import bip32 from 'bip32'
   * import { Address, TransactionBuilder, Networks } from 'oip-hdmw'
   * 
   * var accountMaster = bip32.fromBase58("Fprv4xQSjQhWzrCVzvgkjam897LUV1AfxMuG8FBz5ouGAcbyiVcDYmqh7R2Fi22wjA56GQdmoU1AzfxsEmVnc5RfjGrWmAiqvfzmj4cCL3fJiiC", networks.flo.network)
   * var account = new Account(accountMaster, networks.flo, false);
   * 
   * // F8P6nUvDfcHikqdUnoQaGPBVxoMcUSpGDp
   * var addressNode = bip32.fromBase58("Fprv52CvMcVNkt3jU7MjybjTNie1Bqm7T66KBueSVFW74hXH43sXMAUdmk73TENACSHhHbwm7ZnHiaW3DxtkwhsbtpNjsh4EpnFVjZVJS7oxNqw", networks.flo.network)
   * var address = new Address(addressNode, networks.flo, false);
   * 
   * var builder = new TransactionBuilder(networks.flo, {
   * 	from: address,
   * 	to: {"FHQvhgDut1rn1nvQRZ3z9QgMEVMavRo2Tu": 0.00001},
   * 	floData: "Testing oip-hdmw!"
   * }, account)
   * 
   * builder.sendTX().then((txid) => {
   * 	console.log(txid)
   * })
   * @return {Promise<string>} Returns a promise that will resolve to the success TXID
   */

	}, {
		key: 'sendTX',
		value: async function sendTX(manual_hex) {
			var hex = manual_hex;

			if (!hex) {
				try {
					hex = await this.buildTX();
				} catch (e) {
					throw new Error("Unable to build Transaction \n" + e);
				}
			}

			if (hex) {
				console.log("BroadcastHex: " + hex);

				var response = void 0;
				try {
					response = await this.coin.explorer.broadcastRawTransaction(hex);
				} catch (e) {
					throw new Error("Unable to Broadcast Transaction hex! \n" + e);
				}

				var txid;

				// Handle { txid: "txid" }
				if (response && typeof response.txid === "string") txid = response.txid;

				/**
     * Handle
     * { 
     *    txid: { 
     *        result: '05d2dd88d69cc32717d315152bfb474b0b1b561ae9a477aae091714c4ab216ac',
     *        error: null,
     *        id: 47070 
     *     } 
     * }
     */
				if (response && response.txid && response.txid.result) {
					txid = response.txid.result;
				}

				/**
     * Handle
     * { 
     *     result: '05d2dd88d69cc32717d315152bfb474b0b1b561ae9a477aae091714c4ab216ac',
     *     error: null,
     *     id: 47070 
     * }
     */
				if (response && response.result) {
					txid = response.result;
				}

				// Add txid to spentTransactions for each spent input
				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;

				try {
					for (var _iterator6 = this.selected.inputs[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var inp = _step6.value;
						var _iteratorNormalCompletion7 = true;
						var _didIteratorError7 = false;
						var _iteratorError7 = undefined;

						try {
							for (var _iterator7 = this.from[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
								var addr = _step7.value;

								if (addr.getPublicAddress() === inp.address) {
									addr.addSpentTransaction(inp.txId);
								}
							}
						} catch (err) {
							_didIteratorError7 = true;
							_iteratorError7 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion7 && _iterator7.return) {
									_iterator7.return();
								}
							} finally {
								if (_didIteratorError7) {
									throw _iteratorError7;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6.return) {
							_iterator6.return();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}

				return txid;
			} else {
				throw new Error("TransactionBuilder.buildTX() did not create any hex!");
			}
		}
	}]);

	return TransactionBuilder;
}();

module.exports = TransactionBuilder;